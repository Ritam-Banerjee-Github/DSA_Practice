// This width includes all null nodes in a level -
class Pair{
		TreeNode node;
		int data;
		public Pair(TreeNode node, int data){
			this.node=node;
			this.data=data;
		}
	}
public class Solution {
	static class Pair{
		TreeNode node;
		int data;
		public Pair(TreeNode node, int data){
			this.node=node;
			this.data=data;
		}
	}
	public static int getMaxWidth(TreeNode root) {
		// Write your code here.
		if(root==null) return 0;
		int ans=0;
		Queue<Pair> queue=new LinkedList<>();
		queue.add(new Pair(root,0));
		while(!queue.isEmpty()){
			int size=queue.size();
			int curr_min=queue.peek().data;
			
			int first=0;
			int last=0;

			for(int i=0;i<size;i++){
				Pair curr=queue.peek();
				queue.remove();
				int level=curr.data-curr_min;
				if(i==0){
					first=level;
				}
				if(i==size-1){
					last=level;
				}
				if(curr.node.left!=null){
					queue.add(new Pair(curr.node.left,2*level+1));
				}
				if(curr.node.right!=null){
					queue.add(new Pair(curr.node.right,2*level+2));
				}
			}
			ans=Math.max(ans,last-first+1);
		}
		return ans;

	}
}


// This excludes all null nodes in the level -

public class Solution {
	static class Pair{
		TreeNode node;
		int data;
		public Pair(TreeNode node, int data){
			this.node=node;
			this.data=data;
		}
	}
	public static int getMaxWidth(TreeNode root) {
		// Write your code here.
		if(root==null) return 0;
		int ans=0;
		Queue<TreeNode> queue=new LinkedList<>();
		queue.add(root);
		while(!queue.isEmpty()){
			int size=queue.size();
			for(int i=0;i<size;i++){
				TreeNode curr=queue.peek();
				queue.remove();
				
				if(curr.left!=null){
					queue.add(curr.left);
				}
				if(curr.right!=null){
					queue.add(curr.right);
				}
			}
			ans=Math.max(ans,size);
		}
		return ans;

	}
}


Time Complexity: O(N)

Reason: We are doing a simple level order traversal. The inner loop simply traverses the nodes level-wise and doesnâ€™t add to the complexity.

Space Complexity: O(N)