In a path, every node must appear once.
Maximum Depth is known as Height of Binary Tree
Height ->
if(node==null) return 0;

int lh=(node.left)
int rh=(node.right)

return 1+Math.max(lh,rh)

Diameter of BT -> Length of longest path b/w any 2 nodes
if(node==null) return 0; 
int lh=(node.left)
int rh=(node.right)

maxi[0]=Math.max(maxi[0],lh+rh)

return 1+Math.max(lh,rh)

Maximum Path Sum ->
if(node==null) return 0;
int lh=(0,func(node.left,maxi))//Ignoring paths with negative sum
int rh=(0.func(node.right,maxi)) //Ignoring paths with negative sum

maxi[0]=Math.max(maxi[0],node.val+lh+rh)

return node.val+Math.max(lh,rh)

Symmetry ->
if(left==null || right==null)
return (left==right)

return ((left.data==right.data) && funct(left.left,right.right) && funct(left.right && right.left))

Maximum Width ->
Queue<Pair> q where Pair contains node and number denoting value at current level (last-first+1)
int min=q.peek().num
int first=0,last=0;
for(int i=0;i<q.size();i++){
int currId=q.peek().num-min;
TreeNode node=pq.peek().node;
p.poll()
....
if(i==0) first=currId;
if(i==size-1) last=currId;
if(node.left!=null) q.add(new Pair(node.left,currId*2+i)); // for 0 based indexing

For Unique Binary Tree ->
 Inorder & PreOrder/PostOrder
