// Using Linear Search

class Event{
    int start;
    int end;
    int value;
    public Event(int start,int end,int value){
        this.start=start;
        this.end=end;
        this.value=value;
    }
}
class Solution {
    private int solve(int i,int n,int eventNum, int k,int[][] eventList,int[][] dp){
        if(i>=n || eventNum>=k) return 0;
        
        if(dp[i][eventNum]!=-1) return dp[i][eventNum];

        int notTake=solve(i+1,n,eventNum,k,eventList,dp);
        int index=0;
        for(index=i+1;index<eventList.length;index++){
           if(eventList[i][1]<eventList[index][0]) break;
        }
        int take=eventList[i][2]+solve(index,n,eventNum+1,k,eventList,dp);

        return dp[i][eventNum]=Math.max(notTake,take);
    }
    public int maxValue(int[][] events, int k) {
        // ArrayList<Event> eventList=new ArrayList<>();

        // for(int i=0;i<events.length;i++){
        //      eventList.add(new Event(events[i][0],events[i][1],events[i][2])); //Another method. But giving TLE
        // }

        // Collections.sort(eventList,new Comparator<Event>(){
        //     public int compare(Event a, Event b){
        //         if(a.start>b.start){
        //             return 1;
        //         }else if( a.start<b.start){
        //             return -1;
        //         }else{
        //             return 0;
        //         }
        //     }
        // });

        Arrays.sort(events,(a,b)->{
            if(a[0]>b[0]) return 1;
            else if(a[0]<b[0]) return -1;
            else{
                return 0;
            }
        });

        int[][] dp=new int[events.length+1][k+1];
        for(int[] row:dp){
            Arrays.fill(row,-1);
        }
        return solve(0,events.length,0,k,events,dp);
    }
}

// Using Binary Search
class Event{
    int start;
    int end;
    int value;
    public Event(int start,int end,int value){
        this.start=start;
        this.end=end;
        this.value=value;
    }
}
class Solution {
     private int binarySearch(int target,int[][] events,int start){
      int left=start, right=events.length;
      while(left<right){
        int mid=(left+right)/2;
        if(events[mid][0]<=target){
          left=mid+1;
        }
        else{
          right=mid;
        }
      }
      return left;
    }
    private int solve(int i,int n,int eventNum, int k,int[][] eventList,int[][] dp){
        if(i>=n || eventNum>=k) return 0;
        
        if(dp[i][eventNum]!=-1) return dp[i][eventNum];

        int notTake=solve(i+1,n,eventNum,k,eventList,dp);
        int index=binarySearch(eventList[i][1],eventList,i);;
        int take=eventList[i][2]+solve(index,n,eventNum+1,k,eventList,dp);

        return dp[i][eventNum]=Math.max(notTake,take);
    }

    public int maxValue(int[][] events, int k) {
       
        Arrays.sort(events,(a,b)->{
            if(a[0]>b[0]) return 1;
            else if(a[0]<b[0]) return -1;
            else{
                return 0;
            }
        });

        int[][] dp=new int[events.length+1][k+1];
        for(int[] row:dp){
            Arrays.fill(row,-1);
        }
        return solve(0,events.length,0,k,events,dp);
    }
}
