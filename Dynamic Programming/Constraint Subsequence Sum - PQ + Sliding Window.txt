Both Recur + Memo && Tabulation (which are all similar to LIS pattern) were giving TLE due to high value of index. TC was n*n. So we have optimized the tabulation of LIS using PQ(max value and pair) to O(nlogn) from O(N^2)

class Pair{
    int sum;
    int index;

    public Pair(int sum, int index){
        this.sum=sum;
        this.index=index;
    }
}
class Solution {

    public int constrainedSubsetSum(int[] nums, int k) {

        PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>(){
          public int compare(Pair a, Pair b){
              if(a.sum<b.sum) return 1;
              else if(a.sum > b.sum) return -1;
              else return 0;
          }
        }); // Max heap PQ with max sum on top.

        int n=nums.length;
        int[] dp=new int[n];

        for(int i=0;i<n;i++){
           dp[i]=nums[i];   //Max sum of array subsequence till that index. Intially the sum will the original value at that index only
        }

        pq.add(new Pair(temp[0],0));
        int result=temp[0];

        for(int i=1;i<n;i++){
            while(!pq.isEmpty() && i-pq.peek().index > k){
                pq.poll(); //No need to push this popped value later as the index will keep on increasing. So we would have to pop this in future as well. Now all push and pop will be done once only 
            }
            dp[i]=Math.max(dp[i],pq.peek().sum+nums[i]); // Max heap PQ will return max sum from the top
            pq.add(new Pair(dp[i],i));
            result=Math.max(result,dp[i]);
        }
     
        return result;

    }
}