class Solution {
    
    private boolean isPalindrome(String s, int i, int j,int[][] dp){
        if(i>=j){
             dp[i][j]=1;
             return true;
        }
        if(dp[i][j]!=-1) return dp[i][j]==0?false:true;

        if(s.charAt(i)==s.charAt(j)){
         dp[i][j]=(isPalindrome(s,i+1,j-1,dp))?1:0;
         return (dp[i][j]==1)?true:false;
        }
        dp[i][j]=0;
        return false;
    }
    public String longestPalindrome(String s) {
        int n=s.length();
        int[][] dp=new int[n+1][n+1];
        for(int[] row: dp){
            Arrays.fill(row,-1);
        }
        int len=Integer.MIN_VALUE;
        int sp=0;
       
       for(int i=0;i<n;i++){
           for(int j=i;j<n;j++){
               if(isPalindrome(s,i,j,dp)){
                   if(j-i+1>len){
                     sp=i;
                     len=j-i+1;
                   }
               }
           }
       }

       return s.substring(sp,sp+len);
    }
}

Optimized : Using new Template

class Solution {
    public String longestPalindrome(String s) {
        String ans="";
        int maxLength=0;
        int n=s.length();
        int[][] dp=new int[1001][1001];
        
        for(int len=1;len<=n;len++){          //For each length of substring from 1 till n.
            for(int i=0;i+len-1<n;i++){
                int j=i+len-1;
                
                if(len==1){
                    dp[i][j]=1;
                }else if(len==2){
                    dp[i][j]=(s.charAt(i+1)==s.charAt(i))?1:0;
                }else{
                    dp[i][j]=(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==1)?1:0;
                }
                
                if(dp[i][j]==1){
                    if(len>maxLength){
                        ans=s.substring(i,j+1);
                    }
                }
            }
        }
        
        return ans;
    }
}

TC - O(N^2)
SC - O(N^2)