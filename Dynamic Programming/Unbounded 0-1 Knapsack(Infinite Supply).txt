class Solution{
    static int f(int i, int W, int val[], int wt[],int dp[][]){
        if(i==0){
            if(wt[0]<=W) return (W/wt[0])*val[0];
            return 0;
        }
        if(dp[i][W]!=-1) return dp[i][W];
        int notTake=f(i-1,W,val,wt,dp);
        int take=-(int)1e8;
        if(wt[i]<=W){
            take=val[i]+f(i,W-wt[i],val,wt,dp);
        }
        
        return dp[i][W]=Math.max(take,notTake);
    }
    static int knapSack(int N, int W, int val[], int wt[])
    {
        // code here  
        int[][] dp=new int[N][W+1];
        for(int i=0;i<N;i++){
            for(int j=0;j<=W;j++){
                dp[i][j]=-1;
            }
        }
        return f(N-1,W,val,wt,dp);
    }
}

Expected Time Complexity: O(N*W)
Expected Auxiliary Space: O(W)