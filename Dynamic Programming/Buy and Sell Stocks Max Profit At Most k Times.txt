import java.util.* ;
import java.io.*; 
public class Solution
{
    private static int utility(int index,int buy,int limit,int[] prices, int n, int[][][] dp){
         if(index==n || limit==0){
             return 0;
         }

         if(dp[index][buy][limit]!=-1) return dp[index][buy][limit];
         int profit=0;

        if(buy==1){
         profit=Math.max(-prices[index]+utility(index+1,0,limit,prices,n,dp),0+utility(index+1,1,limit,prices,n,dp));
        }
        else if(buy==0){
            profit=Math.max(prices[index]+utility(index+1,1,limit-1,prices,n,dp),0+utility(index+1,0,limit,prices,n,dp));
        }

        return dp[index][buy][limit]=profit;
    }
public static int maximumProfit(int[] prices, int n, int k)
    {
        // Write your code here.
        int[][][] dp=new int[n+1][2][k+1];
        for(int i=0;i<=n;i++){
            for(int j=0;j<2;j++){
                for(int z=0;z<=k;z++){
                    dp[i][j][z]=-1;
                }
            }
        }
        return utility(0,1,k,prices,n,dp);
    }
}

Time Complexity: O(N*2*3) 

Reason: There are N*2*K states therefore at max ‘N*2*K’ new problems will be solved.

Space Complexity: O(N*2*K) + O(N)

Reason: We are using a recursion stack space(O(N)) and a 3D array ( O(N*2*K)).

Tabulation ( Bottom Up)

public static int maximumProfit(int[] prices, int n, int k)
    {
        // Write your code here.
        int[][][] dp=new int[n+1][2][k+1];
        for(int i=0;i<=n;i++){
            for(int j=0;j<2;j++){
                for(int z=0;z<=k;z++){
                    dp[i][j][z]=-1;
                }
            }
        }
        for(int buy=0;buy<=1;buy++){
            for(int limit=0;limit<=k;limit++){
                dp[n][buy][limit]=0;
            }
        }
        for(int i=0;i<=n;i++){
           for(int buy=0;buy<=1;buy++){
               dp[i][buy][0]=0;
           } 
        }
        for(int index=n-1;index>=0;index--){
            for(int buy=1;buy>=0;buy--){
                for(int limit=1;limit<=k;limit++){
                         int profit=0;
                         if(buy==1){
                                profit=Math.max(-prices[index]+
                                dp[index+1][0][limit],0+dp[index+1][1][limit]);
                           }else if(buy==0){
                            	profit=Math.max(prices[index]+
                            	dp[index+1][1][limit-1],0+dp[index+1][0][limit]);
                          }
                          dp[index][buy][limit]=profit;
                }
            }
        }
        return dp[0][1][k];
    }
}

Time Complexity: O(N*2*3) 

Reason: There are N*2*K states therefore at max ‘N*2*K’ new problems will be solved.

Space Complexity: O(N*2*K)