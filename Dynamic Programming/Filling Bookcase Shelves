Brute Force : Recursion(2^n)
7 / 20 test cases passed. Status: Time Limit Exceeded

class Solution {
    
    private int solve(int i,int n, int currWidth, int shelfWidth, int currMaxHeight, int[][] books, int booksCount){
        if(i>=n){ 
            if(booksCount==n) return currMaxHeight;
        }
        
        int same=Integer.MAX_VALUE;
        int next=Integer.MAX_VALUE;
        
        if(books[i][0]+currWidth<=shelfWidth){
           same= solve(i+1,n,currWidth+books[i][0],shelfWidth,Math.max(currMaxHeight,books[i][1]),books,booksCount+1);
        }
        
        next=currMaxHeight+solve(i+1,n,books[i][0],shelfWidth,books[i][1],books,booksCount+1);
        
        return Math.min(same,next);
        
    }
    
    public int minHeightShelves(int[][] books, int shelfWidth) {
        int n=books.length;
        return solve(0,n,0,shelfWidth,0,books,0);
            
    }
}

Optimal : Recursion + Memoization
class Solution {  
    HashMap<String,Integer> dp=new HashMap<>();
    
    private int solve(int i,int n, int currWidth, int shelfWidth, int currMaxHeight, int[][] books, int booksCount){
        if(i>=n){ 
            if(booksCount==n) return currMaxHeight;
        }
        
        String key=""+i+currWidth+currMaxHeight;
        
        if(dp.containsKey(key)) return dp.get(key);
        
        int same=Integer.MAX_VALUE;
        int next=Integer.MAX_VALUE;
        
        if(books[i][0]+currWidth<=shelfWidth){
           same= solve(i+1,n,currWidth+books[i][0],shelfWidth,Math.max(currMaxHeight,books[i][1]),books,booksCount+1);
        }
        
        next=currMaxHeight+solve(i+1,n,books[i][0],shelfWidth,books[i][1],books,booksCount+1);
        
        dp.put(key,Math.min(same,next));
        return Math.min(same,next);
        
    }
    
    public int minHeightShelves(int[][] books, int shelfWidth) {
        int n=books.length;
        
        return solve(0,n,0,shelfWidth,0,books,0);
            
    }
}


