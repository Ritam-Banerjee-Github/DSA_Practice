class Solution{
    static int mod =1003;
    private static int utility(int i, int j, String S, int dp[][][],int tf){
        if(i>j) return 0;
        if(i==j){
            if(tf==1) return (S.charAt(i)=='T')?1:0;
            else return (S.charAt(i)=='F')?1:0;
        }
        if(dp[i][j][tf]!=-1) return dp[i][j][tf];
        int ways=0;
        for(int ind=i+1;ind<=j-1;ind+=2){
            int lt=utility(i,ind-1,S,dp,1);
            int lf=utility(i,ind-1,S,dp,0);
            int rt=utility(ind+1,j,S,dp,1);
            int rf=utility(ind+1,j,S,dp,0);
            
            if(S.charAt(ind)=='&'){
                if(tf==1) ways=(ways+ (lt*rt)%mod)%mod;
                else
                   ways= (ways + (lt*rf)%mod + (lf*rf)%mod +(rt*lf)%mod)%mod;
            }
            else if(S.charAt(ind)=='|'){
                if(tf==1) ways= (ways + (lf * rt) % mod + (lt * rf) % mod + (lt * rt) % mod) % mod;
                else ways=(ways + (lf * rf) % mod) % mod; 
            }
            else if(S.charAt(ind)=='^'){
                if(tf==1) ways=(ways + (lf * rt) % mod + (lt * rf) % mod) % mod;
                else ways=(ways + (lf * rf) % mod + (lt * rt) % mod) % mod;
            }
        }
        return dp[i][j][tf]= ways;
    }
    static int countWays(int N, String S){
        // code here
        int[][][] dp=new int[N][N][2];
        for(int i=0;i<N;i++){
         for(int j=0;j<N;j++){
             for(int k=0;k<2;k++){
                 dp[i][j][k]=-1;
             }
           }   
        }
        return utility(0,N-1,S,dp,1);
    }
}
Time Complexity: O(N*N*2 * N) ~ O(N3) There are a total of 2*N2 no. of states. And for each state, we are running a partitioning loop roughly for N times.

Space Complexity: O(2*N2) + Auxiliary stack space of O(N), 2*N2 for the dp array we are using.

