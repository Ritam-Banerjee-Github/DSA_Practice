Brute : Recursion
class Solution {
    private boolean solve(int i, int j, String s, String p){
        if(j==p.length()){
            return (i==s.length());
        }
        
        boolean first_character_match=(i<s.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='.'));
        
        if(j+1<p.length() && p.charAt(j+1)=='*'){
            boolean take=(first_character_match && solve(i+1,j,s,p));
            boolean notTake=solve(i,j+2,s,p);
            
            return (take || notTake);
        }
        
        return (first_character_match && solve(i+1,j+1,s,p));
            
    }
    public boolean isMatch(String s, String p) {
        return solve(0,0,s,p);
    }
}


Optimized: Recursion + Memoization

class Solution {
    private boolean solve(int i, int j, String s, String p,int[][] dp){
        if(j==p.length()){
            return (i==s.length());
        }
        
        if(dp[i][j]!=-1) return dp[i][j]==0?true:false;
        
        boolean first_character_match=(i<s.length() && (s.charAt(i)==p.charAt(j) || p.charAt(j)=='.'));
        
        if(j+1<p.length() && p.charAt(j+1)=='*'){
            boolean take=(first_character_match && solve(i+1,j,s,p,dp));
            boolean notTake=solve(i,j+2,s,p,dp);
            
             dp[i][j]=((take || notTake)==true)?0:1;
            
            return (take || notTake);
        }
        
         dp[i][j]=(first_character_match && solve(i+1,j+1,s,p,dp))==true?0:1;
        
        return dp[i][j]==0?true:false;
            
    }
    public boolean isMatch(String s, String p) {
        int[][] dp=new int[22][22];
        
        for(int[] row:dp){
            Arrays.fill(row,-1);
        }
        
        return solve(0,0,s,p,dp);
    }
}
