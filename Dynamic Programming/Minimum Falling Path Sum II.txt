class Solution {
    private int solve(int i, int j, int n, int m, int[][] grid,int[][] dp){
        if(i==n-1){
            return grid[i][j];
        }
        
        if(dp[i][j]!=-1) return dp[i][j];
        
        int result=Integer.MAX_VALUE;
        
        for(int k=0;k<n;k++){     //To cover all elements of next row except for same column
            if(k==j) continue;
            
            result=Math.min(result,grid[i][j]+solve(i+1,k,n,m,grid,dp));
        }
        
        return dp[i][j]=result;
    }
    
    public int minFallingPathSum(int[][] grid) {
        int n=grid.length;
        int ans=Integer.MAX_VALUE;
        
        int[][] dp=new int[n+2][n+2];
        for(int[] row:dp){
            Arrays.fill(row,-1);
        }
        
        for(int j=0;j<n;j++){
            ans=Math.min(ans,solve(0,j,n,n,grid,dp));
        }
        
        return ans;
    }
}