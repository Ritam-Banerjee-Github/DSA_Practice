class Activity{
    int start;
    int end;
    int profit;
    
    public Activity(int start, int end, int profit){
        this.start=start;
        this.end=end;
        this.profit=profit;
    }
}

class Solution {
    
private int nextIndex(int l,int n,int end,List<Activity> list){
    int r=n-1;
    
    int result=n+1;
    
    while(l<=r){
        int mid=l+(r-l)/2;
        
        if(list.get(mid).start>=end){
            result=mid;
            r=mid-1;
        }else{
            l=mid+1;
        }
    }
    
    return result;
}

private int solve(int index,int n, List<Activity> list,int[] dp){
    if(index>=n) return 0;
    
    if(dp[index]!=-1) return dp[index];
    
    int next=nextIndex(index+1,n,list.get(index).end,list);
    
    int take=list.get(index).profit+solve(next,n,list,dp);
    int notTake=solve(index+1,n,list,dp);
    
    return dp[index]=Math.max(take,notTake);
}
    
public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
        int n=startTime.length;
        
        List<Activity> list=new ArrayList<>();
        
        for(int i=0;i<n;i++){
            list.add(new Activity(startTime[i],endTime[i],profit[i]));
        }
        
        Collections.sort(list,new Comparator<Activity>(){
            public int compare(Activity a, Activity b){
                if(a.start<b.start){
                    return -1;
                }else if(a.start>b.start){
                    return 1;
                }else{
                    return 0;
                }
            }
        });
        
        int[] dp=new int[n+1];
        Arrays.fill(dp,-1);
        
        return solve(0,n,list,dp);
    }
}

//Approach-1 (Recur + Memo)
//T.C : O(nlogn), where n is the number of jobs
//S.C : O(n), where n is the number of jobs.