class Solution{
    private int f(int i,int arr[],int k,int dp[]){
        if(i==0) return 0;
        if(dp[i]!=-1) return dp[i];
        int min=Integer.MAX_VALUE;
        for(int j=1;j<=k;j++){
            if(i-j>=0){
                int jump=f(i-j,arr,k,dp)+Math.abs(arr[i]-arr[i-j]);
                min=Math.min(min,jump);
            }
        }
        return dp[i]=min;
    }
    public int minimizeCost(int arr[],int N,int K){
        //code here
        int[] dp = new int[N];
        Arrays.fill(dp,-1);
        return f(N-1,arr,K,dp);
    }
}
Time Complexity: O(N *K)

Reason: The overlapping subproblems will return the answer in constant time. Therefore the total number of new subproblems we solve is ‘n’. At every new subproblem, we are running another loop for K times. Hence total time complexity is O(N * K).

Space Complexity: O(N)

Reason: We are using a recursion stack space(O(N)) and an array (again O(N)). Therefore total space complexity will be O(N) + O(N) ≈ O(N)