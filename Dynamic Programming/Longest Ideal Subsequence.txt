Recursion + Memoization : 64 / 85 test cases passed
class Solution {
    private int solve(int i, int prev,int n, int k, String s,int[][] dp){
        if(i>=n) return 0;
        
        int notTake=solve(i+1,prev,n,k,s,dp);
        int take=0;
        
        if(prev!=-1 && dp[i][prev]!=-1) return dp[i][prev];
        
        if(prev==-1 || Math.abs(s.charAt(i)-s.charAt(prev))<=k){
            take=1+solve(i+1,i,n,k,s,dp);
        }
        
        if(prev!=-1) dp[i][prev]=Math.max(take,notTake);
        
        return Math.max(take,notTake);
    }
    public int longestIdealString(String s, int k) {
        int n=s.length();
        
        int[][] dp=new int[n+2][n+2];
        
        for(int[] row:dp){
            Arrays.fill(row,-1);
        }
        return solve(0,-1,n,k,s,dp);
    }
}

Note : In Java, for the || (logical OR) operator, if the first condition in an if statement evaluates to true, the second condition won't be evaluated due to short-circuiting behavior. This is because if the first condition is true, the overall expression will be true regardless of the second condition's value.

So, in your case, if prev == -1 evaluates to true, Math.abs(s.charAt(i) - s.charAt(prev)) <= k won't be evaluated because the overall condition will already be true.


Better : LIS Variant - 74 / 85 test cases passed
class Solution {
    public int longestIdealString(String s, int k) {
        int ans=Integer.MIN_VALUE;
        int n=s.length();
        int[] dp=new int[n+1];        
        
        for(int i=0;i<n;i++){
            dp[i]=1;  
            for(int j=0;j<i;j++){
                if(Math.abs(s.charAt(i)-s.charAt(j))<=k && dp[j]+1>dp[i]){
                    dp[i]=dp[j]+1;
                }
            }
            
            ans=Math.max(ans,dp[i]);
        }
        
        return ans;
    }
}

TC : O(N*N)

Optimal : Range bound LIS Variant
class Solution {
    public int longestIdealString(String s, int k) {
        int ans=Integer.MIN_VALUE;
        int n=s.length();
        int[] dp=new int[26];  
       
        
        for(int i=0;i<n;i++){
           int index=s.charAt(i)-'a';
            
           int left=Math.max(0,index-k);
           int right=Math.min(25,index+k);
            
           int longest=Integer.MIN_VALUE;
            
           for(int j=left;j<=right;j++){
               longest=Math.max(longest,dp[j]);
           } 
           
           dp[index]=longest+1; 
           ans=Math.max(ans,dp[index]);
        }
        
        return ans;
    }
}

TC : O(N*26)
