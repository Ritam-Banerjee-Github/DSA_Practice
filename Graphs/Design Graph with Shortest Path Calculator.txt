class Pair{
    int node;
    int distance;

    public Pair(int node, int distance){
        this.node=node;
        this.distance=distance;
    }
}
class Graph {
    List<List<Pair>> adj=new ArrayList<>();
    int n;
    public Graph(int n, int[][] edges) {
        this.n=n;
        for(int i=0;i<n;i++){
           adj.add(new ArrayList<>());
        }

        int m=edges.length;
        for(int i=0;i<m;i++){
            int u=edges[i][0];
            int v=edges[i][1];
            int distance=edges[i][2];

            adj.get(u).add(new Pair(v,distance));
        }

    }
    
    public void addEdge(int[] edge) {
        int u=edge[0];
        int v=edge[1];
        int distance=edge[2];

        adj.get(u).add(new Pair(v,distance));
    }
    
    public int shortestPath(int node1, int node2) {
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.distance - b.distance);

        int[] dist = new int[n];
        for(int i=0;i<n;i++){
            dist[i] = Integer.MAX_VALUE;
        }
        dist[node1] = 0;
        pq.add(new Pair(node1,0));

        while(!pq.isEmpty()){
            int node = pq.peek().node;
            int dis = pq.peek().distance;
            if(node==node2){  //Because it is PQ, so the first time we get node2, it will have the minimum value
                return dis;
            }
            pq.remove();

            for(Pair edge: adj.get(node)){
                int edgeNode = edge.node;
                int edgeWt = edge.distance;
                if(dis+edgeWt<dist[edgeNode]){
                    dist[edgeNode] = dis+edgeWt;
                    pq.add(new Pair(edgeNode,dist[edgeNode]));
                }
            }
        }

        return -1;
    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * Graph obj = new Graph(n, edges);
 * obj.addEdge(edge);
 * int param_2 = obj.shortestPath(node1,node2);
 */

OR

class Graph {
    class Pair{
    int node;
    int distance;

    public Pair(int node, int distance){
        this.node=node;
        this.distance=distance;
    }
}
    List<List<Pair>> adj=new ArrayList<>();
    int n;
    public Graph(int n, int[][] edges) {
        this.n=n;
        for(int i=0;i<n;i++){
           adj.add(new ArrayList<>());
        }

        int m=edges.length;
        for(int i=0;i<m;i++){
            int u=edges[i][0];
            int v=edges[i][1];
            int distance=edges[i][2];

            adj.get(u).add(new Pair(v,distance));
        }

    }
    
    public void addEdge(int[] edge) {
        int u=edge[0];
        int v=edge[1];
        int distance=edge[2];

        adj.get(u).add(new Pair(v,distance));
    }
    
    public int shortestPath(int node1, int node2) {
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.distance - b.distance);

        int[] dist = new int[n];
        for(int i=0;i<n;i++){
            dist[i] = Integer.MAX_VALUE;
        }
        dist[node1] = 0;
        pq.add(new Pair(node1,0));

        while(!pq.isEmpty()){
            int node = pq.peek().node;
            int dis = pq.peek().distance;
            if(node==node2){
                return dis;
            }
            pq.remove();
            for(Pair edge: adj.get(node)){
                int edgeNode = edge.node;
                int edgeWt = edge.distance;
                if(dis+edgeWt<dist[edgeNode]){
                    dist[edgeNode] = dis+edgeWt;
                    pq.add(new Pair(edgeNode,dist[edgeNode]));
                }
            }
        }
        return -1;
    }
}

/**
 * Your Graph object will be instantiated and called as such:
 * Graph obj = new Graph(n, edges);
 * obj.addEdge(edge);
 * int param_2 = obj.shortestPath(node1,node2);
 */
