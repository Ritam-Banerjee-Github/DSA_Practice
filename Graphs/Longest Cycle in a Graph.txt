class Solution {
    int ans=-1;
    
    private void dfs(int node, int[] vis, List<List<Integer>> adj, int[] pathVis, int[] count){
        vis[node]=1;
        pathVis[node]=1;
        
        for(int next:adj.get(node)){
            
            if(vis[next]!=1){
                count[next]=count[node]+1;
                dfs(next,vis,adj,pathVis,count);
            }else if(pathVis[next]==1){
                 
                ans=Math.max(ans,count[node]-count[next]+1);    //We need to store count to get actual length of the cylce nodes only. Count is basically the length or number of nodes we have encounter at that particular point.
            } 
        }
        
        pathVis[node]=0;
    }
    public int longestCycle(int[] edges) {
        int n=edges.length;
        List<List<Integer>> adj=new ArrayList<>();
        for(int i=0;i<n;i++){
            adj.add(new ArrayList<>());
        }
        
        for(int i=0;i<n;i++){
            if(edges[i]==-1) continue;
            adj.get(i).add(edges[i]);
        }
        
        int[] vis=new int[n];
        int[] pathVis=new int[n];
        int[] count =new int[n];  //We need to store count to get actual length of the cylce nodes only. Count is basically the length or number of nodes we have encounter at that particular point.

        Arrays.fill(count,1);
        
        for(int i=0;i<n;i++){
            if(vis[i]!=1){
                dfs(i,vis,adj,pathVis,count);
            }
        }
        
        return ans;
    }
}