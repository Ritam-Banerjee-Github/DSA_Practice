class Solution {
    int ans=0;
    
    private int dfs(int node, int parent, List<List<Integer>> adj, String s){
        int longest=0;
        int secondLongest=0;
        
          for(int next:adj.get(node)){
              if(next==parent) continue;
              
              int childLength=dfs(next,node,adj,s);
              
              if(s.charAt(node)==s.charAt(next)) continue;  //If we move this above the dfs call for child, then if there is max value from child, that won't be calculated.
              
              if(childLength>longest){
                  secondLongest=longest;
                  longest=childLength;
              }else if(childLength>secondLongest){
                  secondLongest=childLength;
              }
              
          } 
        
        int pathFoundBelow=1+longest+secondLongest; //Why this 1 ? Because including the curr node itself
        int noPathBelow=1; //only curr node is valid, rest children have duplicate character
        int onePathBelow=1+Math.max(longest,secondLongest);
        
        ans=Math.max(ans,Math.max(noPathBelow,Math.max(pathFoundBelow,onePathBelow)));
        
        return Math.max(noPathBelow,onePathBelow);
    }

    public int longestPath(int[] parent, String s) {
        int n=parent.length;
        List<List<Integer>> adj=new ArrayList<>();
        for(int i=0;i<n;i++){
            adj.add(new ArrayList<>());
        }
        
        for(int i=0;i<n;i++){
            int u=parent[i];
            int v=i;
            
            if(u==-1) continue;
            
            adj.get(u).add(v);
            adj.get(v).add(u);
        }
        
        dfs(0,-1,adj,s);
        return ans;
    }
}