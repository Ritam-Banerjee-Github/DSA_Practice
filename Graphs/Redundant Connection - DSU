Self Approach - DSU

class DSU{
    int n;
    List<Integer> ultimateParent=new ArrayList<>();
    List<Integer> size=new ArrayList<>();

    public DSU(int n){
        this.n=n;
        for(int i=0;i<=n;i++){
            size.add(1);
            ultimateParent.add(i);
        }
    }

    public int findUltimateParent(int node){
         if(ultimateParent.get(node)==node) return node;

         int parent=findUltimateParent(ultimateParent.get(node));
         ultimateParent.set(node,parent);
         return parent;
    }

    public void unionBySize(int u, int v){
        int ultimateParentU=findUltimateParent(u);
        int ultimateParentV=findUltimateParent(v);

        if(ultimateParentU==ultimateParentV) return;

        if(size.get(ultimateParentU)>size.get(ultimateParentV)){
            ultimateParent.set(ultimateParentV,ultimateParentU);
            size.set(ultimateParentU,size.get(ultimateParentU)+size.get(ultimateParentV));
        }else{
             ultimateParent.set(ultimateParentU,ultimateParentV);
            size.set(ultimateParentV,size.get(ultimateParentU)+size.get(ultimateParentV));

        }

        this.n--;
    }

}
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        int n=edges.length;
        DSU object=new DSU(n);
        int[] ans=new int[2];

        for(int[] edge: edges){
            int u=edge[0];
            int v=edge[1];

            if(object.findUltimateParent(u)==object.findUltimateParent(v)){
                ans=new int[]{u,v};
            }else{
                object.unionBySize(u,v);
            }
        }


        return ans;
    }
}
