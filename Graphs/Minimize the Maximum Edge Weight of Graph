Binary Search on Answers + DFS with Constraints !!!
class Solution {
    public int minMaxWeight(int n, int[][] edges, int threshold) {
        int low=0;
        int high=0;

        for(int[] edge : edges){
            high=Math.max(high,edge[2]);
        }

        return binarySearch(low,high,n,edges,threshold);
    }

    private int binarySearch(int low, int high, int n, int[][] edges, int threshold){
        int ans=-1;
        while(low<=high){
            int mid=low+(high-low)/2;

            if(isGraphPossible(mid,n,edges,threshold)){
                ans=mid;
                high=mid-1;
            }else{
                low=mid+1;
            }
        }
        return ans;
    }

    private boolean isGraphPossible(int maxWeight, int n, int[][] edges, int threshold){
        List<List<Integer>> adj=new ArrayList<>();
        for(int i=0;i<n;i++){
            adj.add(new ArrayList<>());
        }

        for(int[] edge:edges){
            int u=edge[0];
            int v=edge[1];
            int wt=edge[2];

            if(wt<=maxWeight){
                adj.get(v).add(u);   // making graph with reverse edges, as this is best way to find if all nodes can reach to zero
            }
        }

        Set<Integer> visited=new HashSet<>();
        dfs(0,adj,visited);

        if(visited.size()==n) return true;

        return false;
    }

    private void dfs(int node, List<List<Integer>> adj, Set<Integer> visited){
        visited.add(node);

        for(int next : adj.get(node)){
           if(!visited.contains(next)){
            dfs(next,adj,visited);
           }
        }
    }
}
