Note : Whenever start and end is given for any kind of weight graph, use Dijkstra's (Only except graphs with negative edges cycle, use Bellman/Floyd there)

class Pair{
    int node;
    double prob;
    
    public Pair(int node, double prob){
        this.node=node;
        this.prob=prob;
    }
}
class Solution {
   
    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {
        List<List<Pair>> adj=new ArrayList<>();
        for(int i=0;i<n;i++){
            adj.add(new ArrayList<>());
        }
        for(int i=0;i<edges.length;i++){
            int u=edges[i][0];
            int v=edges[i][1];
            double w=succProb[i];
            
            adj.get(u).add(new Pair(v,w));
            adj.get(v).add(new Pair(u,w));
        }
        
        double[] ans=new double[n];
        Arrays.fill(ans,Double.MIN_VALUE);
        
        ans[start_node]=1;
        
        PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>(){
            public int compare(Pair a, Pair b){
                if(a.prob>b.prob) return -1;
                if(a.prob<b.prob) return 1;
                return 0;
            }
        });
        
        pq.add(new Pair(start_node,1));
        
        while(!pq.isEmpty()){
            Pair p=pq.remove();
            int node=p.node;
            double currProb=p.prob;
            
            if(node==end_node) return currProb;
            
            for(Pair q:adj.get(node)){
                int next=q.node;
                double probability=q.prob;
                
                if(currProb*probability>ans[next]){
                    ans[next]=currProb*probability;
                    pq.add(new Pair(next,ans[next]));
                }
            }
        }
        
        
        return 0;
       
    }
}
