class Pair{
    int time;
    int node;
    
    public Pair(int node, int time){
        this.time=time;
        this.node=node;
    }
}
class Solution {
    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {
        List<Integer> ans=new ArrayList<Integer>();
        int[] persons=new int[n];
        
        List<List<Pair>> adj=new ArrayList<>();
        for(int i=0;i<n;i++){
            adj.add(new ArrayList<Pair>());
        }
        
        for(int i=0;i<meetings.length;i++){
            int u=meetings[i][0];
            int v=meetings[i][1];
            int time=meetings[i][2];
            
            adj.get(u).add(new Pair(v,time));
            adj.get(v).add(new Pair(u,time));
        }
        
        PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>(){
           public int compare(Pair a,Pair b){
               if (a.time>b.time) return 1;
               return -1;
           }    
        });
        
        pq.add(new Pair(0,0));
        pq.add(new Pair(firstPerson,0));
        
        
        while(!pq.isEmpty()){
            Pair p=pq.peek();
            int person=p.node;
            int time=p.time;
            pq.poll();
            
            if(persons[person]==1) continue;
            
            persons[person]=1;
            
            for(Pair q : adj.get(person)){
                int nextPerson=q.node;
                int nextTime=q.time;
                
                if(nextTime>=time && persons[nextPerson]!=1){
                    pq.add(new Pair(nextPerson,nextTime));
                }
            }
        }
        
        
        for(int i=0;i<n;i++){
            if(persons[i]==1){
                ans.add(i);
            }
        }
        
        return ans;
        
    }
}

T.C : ~O((N+M) * (log(M+N) + M)) 
S.C : O(N+M)