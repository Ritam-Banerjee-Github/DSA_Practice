//Here edge weight is 1 (each distance)
class Pair{
    int node;
    int distance;

    public Pair(int node, int distance ){
        this.node=node;
        this.distance=distance;
    }
}


class Solution {
    public int closestMeetingNode(int[] edges, int node1, int node2) {
        int n=edges.length;
        List<List<Integer>> adj=new ArrayList<>();
        for(int i=0;i<n;i++){
           adj.add(new ArrayList<>());
        }

        for(int i=0;i<edges.length;i++){
            if(edges[i]!=-1) adj.get(i).add(edges[i]);
        }

        int[] dist1=new int[n];
        Arrays.fill(dist1,Integer.MAX_VALUE);

        int[] dist2=new int[n];
        Arrays.fill(dist2,Integer.MAX_VALUE);

        dijkstra(node1,adj,dist1);
        dijkstra(node2,adj,dist2);

        int ans=-1;
        int currMin=Integer.MAX_VALUE;


        for(int i=0;i<n;i++){
           if(dist1[i] == Integer.MAX_VALUE || dist2[i] == Integer.MAX_VALUE) continue;

           int currMax=Math.max(dist1[i],dist2[i]);
           if(currMax<currMin){
            currMin=currMax;
            ans=i;
           }

        }

        return ans;
    }

    private void dijkstra(int node,List<List<Integer>> adj,int[] dist){
        PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>(){
            public int compare(Pair a, Pair b){
                if(a.distance<b.distance) return -1;
                if(a.distance>b.distance) return 1;
                return 0;
            }
        });

        pq.add(new Pair(node,0));
        dist[node]=0;

        while(!pq.isEmpty()){
            Pair pair=pq.remove();
 
            for(int next: adj.get(pair.node)){
                if(dist[next]>dist[pair.node]+1){
                    dist[next]=dist[pair.node]+1;
                    pq.add(new Pair(next,dist[next]));
                }
            }
        }
    }
}
