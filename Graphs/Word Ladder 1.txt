class Pair {
    String value;
    int steps;
    Pair(String _first, int _second) {
        this.value = _first;
        this.steps = _second;
    }
}

class Solution
{
    public int wordLadderLength(String startWord, String targetWord, String[] wordList)
    {
        //Code here
        Queue<Pair> q=new LinkedList<Pair>();
        Set<String> st=new HashSet<String>();
        int iniSteps=1;
        q.add(new Pair(startWord,iniSteps));
        int len=wordList.length;
        for(int i=0;i<len;i++){
            st.add(wordList[i]);  // Converting given wordList array to Set to optimize time complexity as we need to keep on searching for the word. In array, linear searh would have taken O(n) time complexity. We dont want that. Set will reduce TC.  
        }

        //  st.remove(startWord); (Not sure why we need to remove startWord as all test cases are running without removing also. Only if given word exists in set then we would need to remove here. But that was not in any test case.

        while(!q.isEmpty()){
            String word=q.peek().value;
            int step=q.peek().steps;
            q.remove();
            
            if(word.equals(targetWord)==true) return step;
            
            for(int i=0;i<word.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char wordToCharArray[] = word.toCharArray(); // Convert String word to character array
                    wordToCharArray[i]=ch;
                    String replacedString=new String(wordToCharArray); // Convert char array to String
                
                    if(st.contains(replacedString)==true){
                    st.remove(replacedString);
                    q.add(new Pair(replacedString,step+1));
                    }
                }
            }
        }
        
        return 0;
        
         
    }
}

Expected Time Compelxity: O(N^2 * M)
Expected Auxiliary Space: O(N * M) where N = length of wordList and M = |wordListi|

