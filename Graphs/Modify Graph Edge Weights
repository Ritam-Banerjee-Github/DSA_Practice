//Using Dijkstra for Shortest Path
//T.C : O(E * E * Log(V)) //E = number of edges, V = number of vertices/nodes
//S.C : O(V+E)
class Pair{
    int node;
    int dist;
    
    public Pair(int node, int dist){
        this.node=node;
        this.dist=dist;
    }
}
class Solution {
    int BIG_VALUE=(int)(2e9);

   // Dijkstra's algorithm to find the shortest path
    private int getShortestDistance(int n, int[][] edges, int source, int destination){
        List<List<Pair>> adj=new ArrayList<>();
        for(int i=0;i<n;i++){
            adj.add(new ArrayList<>());
        }
        
        for(int[] edge:edges){
            if(edge[2]!=-1){
                int u=edge[0];
                int v=edge[1];
                int w=edge[2];
                
                adj.get(u).add(new Pair(v,w));
                adj.get(v).add(new Pair(u,w));
            }
        }
        
        
        PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>(){
           public int compare(Pair a, Pair b){
               if(a.dist<b.dist) return -1;
               if(a.dist>b.dist) return 1;
               return 0;
           } 
        });
        
        
        int[] distance=new int[n];
        Arrays.fill(distance, BIG_VALUE);
        distance[source]=0;
        
        pq.add(new Pair(source,0));
        
        while(!pq.isEmpty()){
            Pair p=pq.remove();
            int node=p.node;
            int dist=p.dist;
            
            
            if(node==destination) break;
            
            for(Pair q:adj.get(node)){
                int next=q.node;
                int wt=q.dist;
                
                if(dist+wt<distance[next]){
                    pq.add(new Pair(next,dist+wt));
                    distance[next]=dist+wt;
                }
            }
        }
        
        return distance[destination];
    }
    
    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {
        int distance=getShortestDistance(n,edges,source,destination);
        if(distance<target) return new int[][]{};
        
        boolean matched=false;
        
        if(distance==target) matched=true;
  
    // Iterate through each edge with -1 weight
        for(int[] edge:edges){
            if(edge[2]==-1){
                
                if(matched==true){
                     edge[2]=BIG_VALUE;   // Assign any random possible value if already matched target value
                }else{
                    edge[2]=1;   // Assign the smallest possible value if no match
                    
                    int newDistance=getShortestDistance(n,edges,source,destination);
                    
                    if(newDistance<=target){
                        edge[2]+=(target-newDistance);  // Adjust weight to match target distance
                        matched=true;
                    }
                }
                
            }
        }
        
        if(matched==false) return new int[][]{};
        return edges;
    }
}


