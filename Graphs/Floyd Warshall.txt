class Solution
{
    public void shortest_distance(int[][] matrix)
    {
        // Code here
        int n=matrix.length; // Here, Graph will be n*n
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(i==j){
                    matrix[i][j]=0;
                } 
                if(matrix[i][j]==-1){
                    matrix[i][j]=(int)(1e9);
                }
            }
        }
        for(int via=0;via<n;via++){
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    if(matrix[i][j]>matrix[i][via]+matrix[via][j]){
                        matrix[i][j]=matrix[i][via]+matrix[via][j];
                    }
                }
            }
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(matrix[i][j]==1e9){
                    matrix[i][j]=-1;
                }
            }
        }

// Detect Negative Weight
        for(int i=0;i<n;i++){
         if(matrix[i][i]<0){
             return true;
            }
          }
        
    }
}
Time Complexity: O(V3), as we have three nested loops each running for V times, where V = no. of vertices.

Space Complexity: O(V2), where V = no. of vertices. This space complexity is due to storing the adjacency matrix of the given graph.