Brute Force : Generate all subarrays
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        int start=0;
        int end=0;
        
        int ans=0;
        int n=nums.length;
        
        for(int i=0;i<n;i++){
            int max=Integer.MIN_VALUE;
            int min=Integer.MAX_VALUE;
            
            for(int j=i;j<n;j++){
                max=Math.max(max,nums[j]);
                min=Math.min(min,nums[j]);
                
                if(Math.abs(max-min)<=limit){
                    ans=Math.max(ans,j-i+1);
                }
            }
        }
     
        return ans;
    }
}

TC - O(N^2)

Optimal :
class Pair{
    int value;
    int index;
    
    public Pair(int value, int index){
        this.value=value;
        this.index=index;
    }
}
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        int start=0;
        int end=0;
        int maxi=Integer.MIN_VALUE;
        int mini=Integer.MAX_VALUE;
        
        int ans=0;
        int n=nums.length;
        
        PriorityQueue<Pair> minHeap=new PriorityQueue<>(new Comparator<Pair>(){
            public int compare(Pair a, Pair b){
                if(a.value<b.value) return -1;
                if(a.value>b.value) return 1;
                if(a.value==b.value){
                    if(a.index<b.index) return -1;
                    return 1;
                }
             return 0;
            }
          
        });
        
        PriorityQueue<Pair> maxHeap=new PriorityQueue<>(new Comparator<Pair>(){
            public int compare(Pair a, Pair b){
                if(a.value>b.value) return -1;
                if(a.value<b.value) return 1;
                if(a.value==b.value){
                    if(a.index<b.index) return -1;
                    return 1;
                }
               return 0; 
            }
        
        });
        while(end<n){
            minHeap.add(new Pair(nums[end],end));
            maxHeap.add(new Pair(nums[end],end));
            
            while(Math.abs(maxHeap.peek().value-minHeap.peek().value)>limit){
                int minIndex=Math.min(minHeap.peek().index,maxHeap.peek().index);
                
                start=minIndex+1;
                if(start>=n) break;
                
                while(minHeap.peek().index<start){
                    minHeap.remove();
                }
                
                while(maxHeap.peek().index<start){
                    maxHeap.remove();
                }
                 
            }
            
            ans=Math.max(ans,end-start+1);
            
            end++;
        }
     
        return ans;
    }
}

TC - O(2N*logN)
SC - O(2N)
