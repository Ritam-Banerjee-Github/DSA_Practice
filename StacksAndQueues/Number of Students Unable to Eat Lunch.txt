class Solution {
    public int countStudents(int[] students, int[] sandwiches) {
       
        int n=students.length;
        
        int countZeroStudents=0;
        int countOneStudents=0;
        
        for(int i=0;i<n;i++){
            if(students[i]==0) countZeroStudents++;
            else countOneStudents++;
        }
        
        for(int i=0;i<n;i++){
            if(sandwiches[i]==0){
                if(countZeroStudents==0) return countOneStudents;
                
                countZeroStudents--;  //Somehow by rotating in queue, they will eat it
            }else{
                if(countOneStudents==0) return countZeroStudents;
                countOneStudents--;  //Somehow by rotating in queue, they will eat it
            }
        }
        
        return 0;
        
    }
}
T.C : O(n)
S.C : O(1)


Approach-2 (Simply simulate whatever the problem asks for)
class Solution {
    public int countStudents(int[] students, int[] sandwiches) {
        int len = students.length;
        Queue<Integer> que = new LinkedList<>();
        Stack<Integer> st = new Stack<>();

        for (int i = 0; i < len; i++) {
            st.push(sandwiches[len - i - 1]);
            que.add(students[i]);
        }

        int lastServed = 0;  //This is how to manage
        while (!que.isEmpty() && lastServed < que.size()) {
            if (st.peek() == que.peek()) {
                st.pop();
                que.poll();
                lastServed = 0;
            } else {
                que.add(que.peek());
                que.poll();
                lastServed++;
            }
        }

        return que.size();
    }
}
T.C : O(n)
S.C : O(n)