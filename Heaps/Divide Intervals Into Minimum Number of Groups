Approach 1 (Self) : Sort + DFS(Only one element in a pass, hence need to use break) 
29 / 35 test cases passed  Status: Time Limit Exceeded

class Pair{
  int start;
    int end;
    public Pair(int start,int end){
        this.start=start;
        this.end=end;
    }
}
class Solution {
    private void dfs(int i, int n, int[] vis, List<Pair> list, int maxEnd){
        if(i==n) return;
        vis[i]=1;
        
        for(int index=i+1;index<n;index++){
            if(vis[index]!=1 && list.get(index).start>maxEnd){
                dfs(index,n,vis,list,list.get(index).end);
                break;
            }
        }
    }
    public int minGroups(int[][] intervals) {
        int n=intervals.length;
        List<Pair> list=new ArrayList<>();
        for(int i=0;i<n;i++){
            list.add(new Pair(intervals[i][0],intervals[i][1]));
        }
        Collections.sort(list,new Comparator<Pair>(){
           public int compare(Pair a, Pair b){
               if(a.start<b.start) return -1;
               if(a.start>b.start) return 1;
               return 0;
           } 
        });
        
        int ans=0;
        int[] vis=new int[n];
        
        for(int i=0;i<n;i++){
            
            if(vis[i]!=1){
                int maxEnd=list.get(i).end;
                dfs(i,n,vis,list,maxEnd);
                ans++;
            }
        }
        
        return ans;
    }
}

Approach 2 : Optimal - Sort + PQ (to store ending point of each group, and then fetch the min from top)
class Pair{
  int start;
    int end;
    public Pair(int start,int end){
        this.start=start;
        this.end=end;
    }
}
class Solution {
 
    public int minGroups(int[][] intervals) {
        int n=intervals.length;
        List<Pair> list=new ArrayList<>();
        for(int i=0;i<n;i++){
            list.add(new Pair(intervals[i][0],intervals[i][1]));
        }
        Collections.sort(list,new Comparator<Pair>(){
           public int compare(Pair a, Pair b){
               if(a.start<b.start) return -1;
               if(a.start>b.start) return 1;
               return 0;
           } 
        });
        
        PriorityQueue<Integer> pq=new PriorityQueue<>();
        
        for(int i=0;i<n;i++){
            int currStart=list.get(i).start;
            int currEnd=list.get(i).end;
            
            if(pq.isEmpty()){
                pq.add(currEnd);
            }else{
                if(pq.peek()<currStart){
                    pq.remove();
                    pq.add(currEnd);
                }else{
                    pq.add(currEnd);
                }
            }
        }
        return pq.size();
    }
}
