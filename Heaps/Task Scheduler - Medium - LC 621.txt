class Solution {
    public int leastInterval(char[] tasks, int n) {
        HashMap<Character,Integer> map=new HashMap<>();
        for(int i=0;i<tasks.length;i++){
            map.put(tasks[i],map.getOrDefault(tasks[i],0)+1);
        }
        
        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());
        
        for(int frequency:map.values()){
            pq.add(frequency);
        }
        
        int ans=0;
        
        while(!pq.isEmpty()){
            
            List<Integer> temp=new ArrayList<>();
            
           for(int i=1;i<=n+1;i++){
               if(!pq.isEmpty()){
                       int freq=pq.peek();
                       pq.remove();
                       freq--;
                       temp.add(freq);
                      } 
               
                 }
            
            for(int freq:temp){
                if(freq>0){
                    pq.add(freq);
                }
            }
            
            if(pq.isEmpty()){
                ans+=temp.size();
            }else{
                ans+=n+1;
            }
        }
        
        return ans;
    }
}

TC : O(N) + O(log(26)) => O(N) + O(k) =>  O(N) : Every operation in PQ takes O(log(size)) and here size can be max 26. Hence, constant 