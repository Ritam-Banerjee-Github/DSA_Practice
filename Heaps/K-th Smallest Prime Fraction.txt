Brute :
class Solution {
    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        PriorityQueue<int[]> pq=new PriorityQueue<>(new Comparator<int[]>(){
          public int compare(int[] a, int[] b){
              double first=(double)a[0]/a[1];
              double second=(double)b[0]/b[1];
                                            
              if(first>second){
                  return 1;
              }else if(first<second){
                  return -1;
              }else{
                  return 0;
              }
          }  
        });
        
        int n=arr.length;
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                int[] currArray={arr[i],arr[j]};
                pq.add(currArray);
            }
        }
        
        int count=0;
        
        while(!pq.isEmpty()){
            int[] currArray=pq.remove();
            count++;
            
            if(count==k) return currArray; 
        }
        
        return new int[]{-1,-1};
    }
}

TC - 
Building PriorityQueue: You iterate through all pairs of elements in the array arr, which results in O(n^2) operations. For each pair, you perform a constant amount of work to create an array and add it to the priority queue. Adding an element to the priority queue (pq.add(currArray)) typically takes O(log(n)) time, where n is the number of elements in the queue.Therefore, the total time complexity for building the priority queue is O(n^2 * log(n^2)), which simplifies to O(n^2 * log(n)).
Removing k Elements from PriorityQueue: You remove elements from the priority queue until you have removed k elements or the queue becomes empty. Removing an element from the priority queue (pq.remove()) typically takes O(log(n)) time.Therefore, the time complexity for removing k elements from the priority queue is O(k * log(n^2)), which simplifies to O(k * log(n)).

O(n^2 * log(n)) + O(k * log(n))

Since k can be at most n^2 in worst case, the dominant term in the time complexity is O(n^2 * log(n)).


Optimal :
class Pair{
    double fraction;
    int i;
    int j;
    
    public Pair(double fraction, int i, int j){
        this.fraction=fraction;
        this.i=i;
        this.j=j;
    }
}
class Solution {
    public int[] kthSmallestPrimeFraction(int[] arr, int k) {
        PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>(){
          public int compare(Pair a, Pair b){
                                            
              if(a.fraction>b.fraction){
                  return 1;
              }else if(a.fraction<b.fraction){
                  return -1;
              }else{
                  return 0;
              }
          }  
        });
        
        int n=arr.length;
        for(int i=0;i<n;i++){
            double fraction=(double)arr[i]/arr[n-1];
            pq.add(new Pair(fraction,i,n-1));
        }
        
        int count=0;
        
        while(!pq.isEmpty()){
            Pair p=pq.remove();
        
            int i=p.i;
            int j=(p.j)-1;
            double fraction=(double)arr[i]/arr[j];
            int[] currArray={arr[i],arr[p.j]};
            count++;
            
            if(count==k) return currArray;
            pq.add(new Pair(fraction,i,j));
        }
        
        return new int[]{-1,-1};
    }
}

T.C : O((n+k)logn)
S.C : O(n)





