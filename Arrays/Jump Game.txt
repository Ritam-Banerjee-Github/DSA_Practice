New Solution -
class Solution {
    public boolean canJump(int[] nums) {
        int n=nums.length;
        
        int max=0;
        int currMax=0;
        
        for(int i=0;i<n;i++){
            if(i>max) return false;
            max=Math.max(max,i+nums[i]);
            if(max>=n-1) return true;
        }
        
        return false;
    }
}

Old Solution -
class Solution {
    static int canReach(int[] A, int N) {
        // code here
        int maxR=0,max=0,jumps=0;
        
        for(int i=0;i<N;i++){
            max=Math.max(max,A[i]+i);  // This is a greedy way to make the maximum possible jump by adding the value of index A[i] to the current index to reach max distance.

            if(i==maxR){
                maxR=max;
                if(maxR>=N-1) return 1;
            }
        }
        return 0;
    }
}


Expected Time Complexity: O(N)
Expected Auxiliary Space: O(1)
