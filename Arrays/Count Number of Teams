Approach 1: Brute Force (Recursion + Memoization)
20 / 72 test cases passed.  Status: Time Limit Exceeded

class Solution {
    HashMap<String,Integer> map=new HashMap<>();
    
    private int solve(int i, int n, int[] rating, List<Integer> temp){
        if(i>=n){
            if(temp.size()==3){
                if(temp.get(0)<temp.get(1) && temp.get(1)<temp.get(2)) return 1;
                if(temp.get(0)>temp.get(1) && temp.get(1)> temp.get(2)) return 1;    
            }
            
            return 0;
        }
        
        String key=""+i+""+temp.toString();
        if(map.containsKey(key)) return map.get(key);
        
        temp.add(rating[i]);
        int take=solve(i+1,n,rating,temp);
        temp.remove(temp.size()-1);
        int notTake=solve(i+1,n,rating,temp);
        
        map.put(key,take+notTake);
        return take+notTake;
    }
    public int numTeams(int[] rating) {
        List<Integer> temp=new ArrayList<>();
        int n=rating.length;
        return solve(0,n,rating,temp);
    }
}

Approach 2: O(n^3) Accepted Solution
class Solution {
    public int numTeams(int[] rating) {
        int n=rating.length;
        int ans=0;
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                for(int k=j+1;k<n;k++){
                    if(rating[i]>rating[j] && rating[j]>rating[k]) ans++;
                    if(rating[i]<rating[j] && rating[j]<rating[k]) ans++;
                }
            }
        }
        
        return ans;
    }
}

Approach 3: O(n^2) (Optimal):  Compute count of left small, left greater, right small, right greater for each index in 1 go
class Solution {
    public int numTeams(int[] rating) {
        int n=rating.length;
        int ans=0;
        for(int j=0;j<n;j++){
            int countLeftSmall=0;
            int countLeftGreater=0;
            int countRightSmall=0;
            int countRightGreater=0;
            
            
            for(int i=0;i<j;i++){
                
                if(rating[i]<rating[j]){
                    countLeftSmall++;
                }else{
                    countLeftGreater++;
                }
            }
            
            for(int k=j+1;k<n;k++){
                 if(rating[j]<rating[k]){
                    countRightGreater++;
                }else{
                    countRightSmall++;
                }
            }
            
            ans+=(countLeftSmall*countRightGreater)+(countLeftGreater*countRightSmall);
        }
        
        return ans;
    }
}
