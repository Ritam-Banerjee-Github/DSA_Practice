My Solution : Brute Force
class Solution {
    public int findTheLongestSubstring(String s) {
        int ans=0;
        int n=s.length();
        int countA=0;
        int countE=0;
        int countI=0;
        int countO=0;
        int countU=0;
        
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                if(s.charAt(j)=='a') countA++;
                if(s.charAt(j)=='e') countE++;
                if(s.charAt(j)=='i') countI++;
                if(s.charAt(j)=='o') countO++;
                if(s.charAt(j)=='u') countU++;

                if(countA%2==0 && countE%2==0 && countI%2==0 && countO%2==0 && countU%2==0){
                    ans=Math.max(ans,j-i+1);
                }
            }
            
                countA=0;
                countE=0;
                countI=0;
                countO=0;
                countU=0;
        }
        
        return ans;
    }
}

Solution 2 : Optimal Approach
Note : Similar to Longest length of subarray with sum=target.

class Solution {
    public int findTheLongestSubstring(String s) {
        int ans=0;
        int n=s.length();
        int[] vowels=new int[5];
        Map<String,Integer> map=new HashMap<>();
        map.put("00000",-1);
        
        for(int i=0;i<n;i++){
          if(s.charAt(i)=='a'){
            vowels[0]=(vowels[0]+1)%2;  
          }
            
          if(s.charAt(i)=='e'){
            vowels[1]=(vowels[1]+1)%2;  
          }
            
          if(s.charAt(i)=='i'){
            vowels[2]=(vowels[2]+1)%2;  
          }
            
          if(s.charAt(i)=='o'){
            vowels[3]=(vowels[3]+1)%2;  
          }
            
          if(s.charAt(i)=='u'){
            vowels[4]=(vowels[4]+1)%2;  
          }
            
          String currState="";   //Arrays.toString(vowels) includes commas and spaes which was not matching
          for(int j=0;j<5;j++){
              currState+=vowels[j];
          }  
            
          if(map.containsKey(currState)){
              ans=Math.max(ans,i-map.get(currState));
          }else{
              map.put(currState,i);
          }  
            
        }
        
        return ans;
    }
}
