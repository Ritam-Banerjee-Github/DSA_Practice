class Solution {
    public int longestPalindrome(String[] words) {
        int ans=0;
        int n=words.length;
        Map<String,Integer> map=new HashMap<>();
        for(int i=0;i<n;i++){
            map.put(words[i],map.getOrDefault(words[i],0)+1);
        }
        boolean isOddOnce=false;

        Set<String> set=new HashSet<>();

        for(int i=0;i<n;i++){
            String word=words[i];
            String reverse=""+word.charAt(1)+word.charAt(0);

            if(set.contains(word) || set.contains(reverse)) continue;

            if(word.equals(reverse)){
                int count=map.get(word);

                if(count%2==0){
                   ans+=count*2;
                }else{
                   if(isOddOnce==true){   //Only one odd occurence we can keep at center of palindrome string
                     count--;
                   }else{
                    isOddOnce=true;
                   }

                   ans+=count*2;
                }

            }else if(map.get(reverse)!=null){
               int count=Math.min(map.get(word),map.get(reverse));
                ans+=count*4;
            }

            set.add(word);
            set.add(reverse);
        }

        return ans;
    }
}
