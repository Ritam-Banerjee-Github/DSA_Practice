Brute Force : 163 / 217 test cases passed.  Status: Time Limit Exceeded
class Solution {
    private boolean isPalindrome(String s){
        int i=0;
        int j=s.length()-1;
        
        while(i<=j){
            if(s.charAt(i)!=s.charAt(j)) return false;
            i++;
            j--;
        }
        
        return true;
    }
    public String nearestPalindromic(String n) {
        long num=Long.parseLong(n);
        
        long temp=num;
        long prev=0;
        
        while(temp>=0){
            temp--;
            
            if(isPalindrome(String.valueOf(temp))){
                prev=temp;
                break;
            }
        }
        
        temp=num;
        long next=0;
        while(true){
            temp++;
            if(isPalindrome(String.valueOf(temp))){
                next=temp;
                break;
            }
        }
        
        long prevDiff=Math.abs(num-prev);
        long nextDiff=Math.abs(num-next);
        
        if(prevDiff<=nextDiff) return String.valueOf(prev);
        
        return String.valueOf(next);
    }
}

Optimal Approach : (Using simple observation)
T.C : O(n)
S.C : O(1) //Ignoring space taken during string copy internally
class Solution {
    public String nearestPalindromic(String n) {
        int len = n.length();
     
        int mid = len / 2;
        long firstHalf = Long.parseLong(n.substring(0, len % 2 == 0 ? mid : mid + 1));
        List<Long> possibleAnswers=new ArrayList<>();
        
        possibleAnswers.add(halfToPalindrome(firstHalf, len % 2 == 0));
        possibleAnswers.add(halfToPalindrome(firstHalf + 1, len % 2 == 0));  //133....ans:141
        possibleAnswers.add(halfToPalindrome(firstHalf - 1, len % 2 == 0));
        
        
        possibleAnswers.add((long)Math.pow(10,len)+1);   // Edge case like 100...001
        possibleAnswers.add((long)Math.pow(10,len-1)-1); // Edge case like 999...
        
        long diff=Long.MAX_VALUE;
        long min=0;
        
        for(long num:possibleAnswers){
            long original=Long.parseLong(n);
            
            if(num==original) continue;
            
            if(Math.abs(original-num)<diff){
                diff=Math.abs(original-num);
                min=num;
            }else if(Math.abs(original-num)==diff){
                min=Math.min(min,num);
            }
        }
        
        return String.valueOf(min);
    }
    
    private long halfToPalindrome(long left, boolean even) {
        long resultNum = left;
        if (!even) {
            left = left / 10;
        }

        // Mirroring the first half to form a palindrome
        while (left > 0) {
            int digit = (int) (left % 10);
            resultNum = (resultNum * 10) + digit;
            left /= 10;
        }
        return resultNum;
    }

}
