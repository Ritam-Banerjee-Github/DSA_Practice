class Solution {
    public int[][] merge(int[][] intervals) {
        int n=intervals.length;
         Arrays.sort(intervals,new Comparator<int[]>(){
             public int compare(int[] a, int[] b){
                 if(a[0]<b[0])return -1;
                 else
                 if(a[0]>b[0]) return 1;
                 else
                 return 0;
             }
         });

         int start=intervals[0][0];
         int end=intervals[0][1];
         List<int[]> list=new ArrayList<>();
         for(int i=1;i<n;i++){
            if(intervals[i][0]<=end){
                end=Math.max(end,intervals[i][1]);
            }
            else{
                list.add(new int[]{start,end});
                start=intervals[i][0];
                end=intervals[i][1];
            }
         }

         list.add(new int[]{start,end});
         int[][] ans=new int[list.size()][2];
         ans=list.toArray(ans);
         return ans;
    }
}

Time Complexity: O(N*logN) + O(N), where N = the size of the given array.
Reason: Sorting the given array takes  O(N*logN) time complexity. Now, after that, we are just using a single loop that runs for N times. So, the time complexity will be O(N).

Space Complexity: O(N), as we are using an answer list to store the merged intervals. Except for the answer array, we are not using any extra space.