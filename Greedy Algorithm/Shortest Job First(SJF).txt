import java.util.* ;
import java.io.*; 
class Pair{
	int arrival;
	int burst;
	public Pair(int arrival,int burst){
		this.arrival=arrival;
		this.burst=burst;
	}
}
public class Solution {
	public static float[] sjf(int n, int[] arrivalTime, int[] burstTime) {		 
		//Write your code here 
		float ans=0.0f;
		List<Pair> list=new ArrayList<>();
		for(int i=0;i<n;i++){
			list.add(new Pair(arrivalTime[i],burstTime[i]));
		}
		Collections.sort(list,new Comparator<Pair>(){
           public int compare(Pair a, Pair b){
			   if(a.arrival<b.arrival){
				   return -1;
			   }
			   else if(a.arrival>b.arrival){
				   return 1;
			   }
			   else if(a.burst<b.burst){
				   return -1;
			   }
			   else if(a.burst>b.burst){
				   return 1;
			   }
			   else return 0;
		   }
		});
        PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>(){
            public int compare(Pair a, Pair b){
				if(a.burst<b.burst) return -1;
				else if(a.burst>b.burst) return 1;
				else
				return 0;
			}
		});
          pq.add(new Pair(list.get(0).arrival,list.get(0).burst));
		  list.get(0).arrival=-1;
		  int waitTime=0;
		int currTime=0;
        int i=1;
		while(!pq.isEmpty()){
			Pair p=pq.peek();
			pq.remove();
			currTime=currTime+p.burst;
			waitTime=waitTime+(currTime-p.burst-p.arrival);  //Aka Turn Around Time
            while(i<n && list.get(i).arrival!=-1 && list.get(i).arrival<=currTime){
                 pq.add(new Pair(list.get(i).arrival,list.get(i).burst));
				 list.get(i).arrival=-1;
				 i++;
			}
		}
		 ans=(float)((float)waitTime/(float)n);
         return new float[] {ans};
    }   
}

